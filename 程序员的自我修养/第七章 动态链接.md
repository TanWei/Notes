### 7.1 为什么要动态链接
1、空间浪费2、程序开发与发布<br/>
动态链接，需要目标文件时，加载到内存中，另外一个程序需要时，不用重新加载。<br/>
优点：1、节省内存；2、减少物理页面的换入换出；3、增加cpu缓存命中率；4、程序升级更加容易；5、程序可以动态的选择加载各种程序模块，可以用来开发插件；<br/>
问题：新旧模块接口不兼容。<br/>
实现的难点：存储管理、内存共享、进程线程机制等<br/>
![图片](./第七章图/动态链接过程.png)
lib.so参与链接过程，lib.so里面保存了完整的符号信息。Program1.o通过lib.so对引用的函数重定位。<br/>
### 7.3
静态共享库，固定装载地址，导致库地址冲突
一种解决方法，<font color='red'>linux和gcc，不使用-fPIC</font>:装载时重定位，不同于静态链接，链接时重定位。<br/>
装载时重定位：一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。又叫做基址重置<br/>
但是有一个<font color='red'>缺点:</font><br/>
指令无法在多进程间共享，浪费内存。<br/>
改进--地址无关代码：把指令中需要修改的部分抽取出来和数据部分放在一起，这样指令部分保持不变，而数据部分可以在每个进程中拥有一个副本。<br/>
![图片](./第七章图/4种寻址模式.png)
#### 类型一
相对地址调用<br/>
```
8048357:e8     e8 ff ff ff<br/>
        call   -24(调用8048357-24地址的函数)
```
#### 类型二
#### 类型三
![图片](./第七章图/模块间的数据访问.png)
当程序中的指令要访问数据b时，程序会先找到GOT(全局偏移表)，然后根据GOT中的变量所对应的项找到变量的目标地址。每个变量都对应一个4个字节的地址，动态链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT的各个项，以确保每个指针所指向的地址正确，由于GOT本身是放在数据段的，所以他可以在模块装载时被改变，并且每个进程都有独立的副本，互相不受影响。<br/>
#### 类型四

![图片](./第七章图/表7-1.各种地址引用方式.png)
#### <font color='red'>如何区分一个DSO是否为pic</font>
![图片](./第七章图/如何区分一个DSO是否为pic.png)
### 7.3.4
```
extern int global;
int foo()
{
    global = 1;
}
```
![图片](./第七章图/无法判断全局变量是否是跨模块调用.png)
![图片](./第七章图/无法判断全局变量是否是跨模块调用的解决方法.png)
一句话：动态模块中的所有全局变量都当做其他模块中定义的，统一使用GOT来实现变量访问。<br/>
### 7.3.5 数据段地址无关性解决
如果数据段中有绝对引用怎么办？<br/>
```
static int a;
static int *p = &a;
```
每个进程有一个独立的副本，可以使用装载时重定位的方案。<br/>
共享对象，编译器与链接器会产生一个重定位表，链接器使用这个重定位表进行对象的重定位。重定位表数据类型--R-386_RELATIVE
### 7.4 延迟绑定
<font color='red'>影响动态链接性能的两个问题：1、动态链接下对于全局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址；对于模块间的调用也要先进行GOT定位，然后在进行间接跳转。2、动态链接的连接工作在运行时完成，即程序开始执行时，动态链接器都要进行一次链接工作，正如我们上面提到的，动态连接器会寻找并装载所需要的共享对象，然后进行符号查找地址重定位等工作，会减慢程序的启动速度。</font>
#### 优化动态链接性能的一些方法:
延迟绑定（针对函数调用的优化，因为全局变量较少）<br/>
函数第一次备用到时才进行绑定<br/>
ELF使用PLT（procedure linkage table）的方法实现。_dl_runtime_resolve(module, funtion)。
```
/*
假设liba.so调用libc.so中的bar函数
*/
bar@plt:
/*
通过GOT进行跳转，第一次调用值为下一条指令jmp *(bar@GOT)，第二次运行值为bar()的地址
*/
jmp *(bar@GOT)
push n          //n是bar函数在liba.so重定位表中的下标（重定位表：需要进行重定位的东东组成的表）
push moduleID   //模块liba的id
jump _dl_runtime_resolve //调用_dl_runtime_resolve
```
上面介绍的是原理，真实实现要复杂一点：<br/>
将GOT拆成的两个表“.got”和“.got.plt”,“.got”保存全局变量的引用地址，“.got.plt”保存函数引用的地址。也就是说，外部函数引用全部被分离出来放到了“.got.plt”中，“.got.plt”还有一个特殊的地方是他的前三项：<br/>
第一项保存了".dynamic"段的地址<br/>
第二项保存的本模块的ID<br/>
第三项保存的_dl_runtime_resolve的地址。<br/>
第二第三项由动态连接器在装载模块的时候初始化，“.got.plt”的其余项分贝对应每个外部函数的引用。
![图片](./第七章图/GOT中的PLT数据结构.png)
### 7.5 动态链接相关结构
####7.5.1 ".interp"段
动态链接器的路径，指向linux系统一个软连接
#### 7.5.2 ".dynamic"段
里面保存的信息有点像ELF文件头，ELF文件头保存的静态链接需要的信息，而".dynamic"段保存了动态连接下所使用的的相应信息。
![图片](./第七章图/表7-2.png)
#### 7.5.3 动态符号表
静态链接中有一个专门的段“.symtab”，里面保存了所有关于该目标文件的符号的定义和引用，动态链接所对应的段为".dynsym",里面只保存了与动态链接相关的符号，模块内部符号，如私有变量等不保存。动态链接模块很多时候同时拥有这两个表。<br/>
#### 7.5.4动态链接重定位表
对于PIC技术的模块，代码段不需要重定位（因为地址无关），但是数据段还包含了绝对地址的引用，包括GOT和前面举得static引用的例子。<br/>
静态链接，".rel.text"表示代码段的重定位表，".rel.data"表示数据段的重定位表<br/>
动态链接，".rel.dyn"实际上是对数据引用的修正，它所修正的位置位于".got"以及数据段，".rel.plt"是对函数引用的修正，它所修正的位置位于".got.plt"。<br/>
#### 7.5.5动态链接时进程堆栈初始化信息
[进程栈初始化的情况](./第六章%20可执行文件的装载与进程.md#6.4.5进程栈初始化)
除了上面的信息，还保存了动态链接器所需要的一些辅助信息数组
### 7.6动态链接的步骤和实现
基本上分为三步：<font color='red'>1、启动动态链接器本身；2、装载所有需要的共享对象；3、重定位和初始化</font>
#### 7.6.1动态链接器自举
动态链接器要求：1、不可以依赖其他任何共享对象；2、动态链接器本身所需要的全局和静态变量的重定位工作由他本身完成（这种具有一定限制条件的启动代码被称为<font color='red'>自举</font>）。
实际上自举代码中，甚至不能调用动态链接器本身的函数。（不同.o中的函数，无法分辨是内部还是外部）<br/>
#### 7.6.2 装载共享对象
1、动态链接器将可执行文件和链接器本身的符号表都合并到全局符号表中。<br/>
2、寻找依赖，一般采用广度优先。<br/>
符号优先级，发生**全局符号介入**（<font color='red'>运行期</font>，一个共享对象里面的全局符号被另一个同名的全局符号覆盖的现象。）
#### 7.6.3 重定位和初始化
重定位：链接器开始重新遍历可执行文件和每个共享对象的重定位表，将他们的GOT/PLT中的每个需要重定位的位置进行修正。<br/>
初始化：.init段来初始化，.finit退出时进行清理工作。如果进程中的可执行文件也有“.init段”，那么动态链接器不会执行共享对象中的“.init段”。
#### 7.6.4 linux动态链接器
1、动态链接器本身是动态链接还是静态链接的？
静态链接，他不能依赖其他共享对象。
2、是不是PIC的？
不关键，实际上是PIC的
3、装载地址
和一般的共享对象没区别，0x00000000.
### 7.7 显示运行时链接
dlopen、dlsym查找符号、dlerror错误处理、dlclose