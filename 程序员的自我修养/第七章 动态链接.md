### 7.1 为什么要动态链接
1、空间浪费2、程序开发与发布<br/>
动态链接，需要目标文件时，加载到内存中，另外一个程序需要时，不用重新加载。<br/>
优点：1、节省内存；2、减少物理页面的换入换出；3、增加cpu缓存命中率；4、程序升级更加容易；5、程序可以动态的选择加载各种程序模块，可以用来开发插件；<br/>
问题：新旧模块接口不兼容。<br/>
实现的难点：存储管理、内存共享、进程线程机制等<br/>
![图片](./第七章图/动态链接过程.png)
lib.so参与链接过程，lib.so里面保存了完整的符号信息。Program1.o通过lib.so对引用的函数重定位。<br/>
### 7.3
一种解决方法，<font color='red'>linux和gcc，不使用-fPIC</font>:装载时重定位，不同于静态链接，链接时重定位。<br/>
装载时重定位：一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。又叫做基址重置<br/>
但是有一个<font color='red'>缺点:</font><br/>
指令无法在多进程间共享，浪费内存。<br/>
改进--地址无关代码：把指令中需要修改的部分抽取出来和数据部分放在一起，这样指令部分保持不变，而数据部分可以在每个进程中拥有一个副本。<br/>
![图片](./第七章图/4种寻址模式.png)
#### 类型一
相对地址调用<br/>
```
8048357:e8     e8 ff ff ff<br/>
        call   -24(调用8048357-24地址的函数)
```
#### 类型二
#### 类型三
![图片](./第七章图/模块间的数据访问.png)
当程序中的指令要访问数据b时，程序会先找到GOT(全局偏移表)，然后根据GOT中的变量所对应的项找到变量的目标地址。每个变量都对应一个4个字节的地址，动态链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT的各个项，以确保每个指针所指向的地址正确，由于GOT本身是放在数据段的，所以他可以在模块装载时被改变，并且每个进程都有独立的副本，互相不受影响。<br/>
#### 类型四

![图片](./第七章图/表7-1.各种地址引用方式.png)
#### <font color='red'>如何区分一个DSO是否为pic</font>
![图片](./第七章图/如何区分一个DSO是否为pic.png)
### 7.3.4
```
extern int global;
int foo()
{
    global = 1;
}
```
![图片](./第七章图/无法判断全局变量是否是跨模块调用.png)
![图片](./第七章图/无法判断全局变量是否是跨模块调用的解决方法.png)
一句话：动态模块中的所有全局变量都当做其他模块中定义的，统一使用GOT来实现变量访问。<br/>
### 7.3.5 数据段地址无关性解决
如果数据段中有绝对引用怎么办？<br/>
```
static int a;
static int *p = &a;
```
每个进程有一个独立的副本，可以使用装载时重定位的方案。<br/>
共享对象，编译器与链接器会产生一个重定位表，链接器使用这个重定位表进行对象的重定位。重定位表数据类型--R-386_RELATIVE
