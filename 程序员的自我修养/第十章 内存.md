### 10.1 程序内存布局
用户空间（除了系统内核占用空间剩余的空间）：栈、堆、可执行文件映像、保留区（受到保护而禁止访问的内存，如NULL）、“动态链接库映射区”<br/>
![图片](./linux进程地址空间布局.png)
栈向低地址增长，堆向高地址增长。<br/>
### 10.2 栈与调用惯例
栈总是向下增长才，在i386下，栈顶由esp寄存器定位，<font color='red'>esp保存了栈顶</font>，压栈esp减小，出栈esp增大。<br/>
栈保存了一个函数调用所需要维护的信息，这常常被称为堆栈帧或活动记录。堆栈帧包括以下几个方面：<br/>
1、函数的返回地址和参数<br/>
2、临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量<br/>
3、保存的上下文：包括在函数调用前后需要保持不变的寄存器。<br/>
一个函数的活动记录用ebp和esp划定范围，esp指向栈顶，ebp指向了函数活动记录的一个固定位置，ebp又被称为帧指针。
![图片](./第十章图/10-4.png)
ebp之前首先是这个函数的返回地址，值为ebp-4,再往前为压入栈中的参数，值为ebp-8，ebp-12等。ebp指向的数据十调用该函数前ebp的值，函数返回时，可以通过这个这个值回复ebp之前的值。一个函数调用总是：<br/>
**·** 把所有或一部分参数压入栈中，如果有其他参数没有入栈，那么使用某些特定的寄存器传递<br/>
**·** 把当前指令的下一条指令的地址压入栈中<br/>
**·** 跳转到函数体执行<br/>
第2、3步由指令call一起执行。
```
int foo()
{
    return 123;
}
```
![图片](./第十章图/10-5.png)
在windows上，可能反汇编如下：<br/>
![图片](./第十章图/钩子.png)
```
mov edi, edi
```
这句代码做占位符，可以用来实现钩子（hook）技术，
#### 10.2.2 调用惯例
1、函数参数的传递顺序和方式<br/>
从左往右还是从右往左，是否使用寄存器传递参数。<br/>
2、栈的维护方式<br/>
弹出工作由函数调用方完成，还是由函数本身来完成。<br/>
3、名字修饰的策略<br/>
![图片](./第十章图/表10-2.png)
C++自己还有一种特殊的调用惯例，称为thiscall，专用于类成员函数的调用，其特点随编译器不同而不同，在VC中是this指针存放于ecx寄存器，参数从右到左压栈，而对于gcc，thiscall和cdecl完全一样，只是将this看作是函数的第一个参数
#### 10.2.3 函数返回值传递

**·** 首先，main函数在栈上额外开辟了一片空间，并将这块空间的一部分作为传递返回值的临时对象，这里称为temp。（无名空间）<br/>
**·** 将temp对象的地址作为隐藏参数传递给return_test函数<br/>
**·** return_test函数将数据拷贝给temp对象，并将temp对象的地址用eax传出<br/>
**·** return_test函数返回之后，main函数将eax指向的temp对象的内容拷贝给n
### 10.3
malloc：先批发一块较大的空间，然后零售给程序。<br/>
批发：linux系统mmap()、windows系统VirtualAlloc()<br/>
零售：堆分配算法
### 10.3.4
堆分配算法：<br/>
1、空闲链表：空闲空间组成的链表。<br/>
释放的时候怎么知道大小？<br/>
用户申请k大小的空间，实际分配k+4大小的空间。多余的4字节用来保存大小<br/>
2、位图：将整个堆划分为大量的块，每个块的大小相同。当用户请求内存的时候，总是分配整数个块的空间给用户，第一个块我们称为已分配区域的头（head），其余的称为已分配区域的主体（body）<br/>
![图片](./第十章图/位图分配方式.png)
3、对象池：每次分配的空间的大小都一样的话，那么就可以按照这个每次请求分配的大小作为一个单位，把整个堆空间划分为大量的小块。<br/>
![图片](./第十章图/glibc堆分配算法.png)