在平时开发的过程中，我们需要记录一些日志。这样，日志库就可以为我们实现这样的需求。这里简要介绍两种开源日志库。注意log4cpp的性能较为一般，不建议在服务器中使用，但是代码可读性较好。log4cpp支持多种输出：网络、本地文件、控制台。而muduo日志库支持的功能不多，但性能较log4cpp好。这里介绍的目的，主要是⽤来分析⼀个⽇志库的[架构](https://so.csdn.net/so/search?q=%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020)，而mudo⽇志的性能较高，主要分析性能以及coredump找回丢失的⽇志。

写函数
---

先介绍一下相关写函数。日志库性能的最大瓶颈是往磁盘写入日志的过程。这里有两个函数，fwrite()和write()。fwrite()是C语言实现的函数，wtrite()是linux提供的接口。fwrite()里面有锁，所以是线程安全的，但最终还是需要调用write()。当然，两个线程同时对同一文件进行写操作，内核会做互斥，只不过fwrite()在应用层就加锁了。  
当一次写入的数据达到一定大小时，使用write()会更快。然而，fwrite()内部会做缓存，对于一次性写入数据不多的情况，不会直接调用write()，会积攒数据到一定大小后才写入。这里可以看出，落盘的实时性和效率是成反比的。这里还要注意一点，其实write()也有缓存write\_buf，内核驱动里会有缓存，与fwrite()缓存的区别是fwrite()的缓存是在应用层中。

日志库
---

对于日志库，我们主要关注两个问题：日志库怎样提高性能，程序崩溃时日志没有及时写入该怎样找回。这两个问题，留到最后回答。这里再提示一下，安装日志库完成后，需要链接库

```
sudo ldconfig

```

否则需要重启才能生效。  
日志库常见功能有⽇志级别、⽇志格式化、⽇志输出、⽇志回滚、⽇志配置⽂件等。注意日志级别不同的日志库可能会有不同。对于日志输出方式，一个日志库应该能同时支持多种输出方式。  
这里再提示一下，如果开了debug，会产生较多日志，需要关注磁盘空间，否则程序容易崩溃。  
另外，日志库一定要支持多线程，内部进行加锁处理。

log4cpp
-------

![](https://img-blog.csdnimg.cn/f0380c330da24136a6e98e1884619a5f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZSP5ZmX,size_20,color_FFFFFF,t_70,g_se,x_16)
  
对于log4cpp，主要学习它的机制：layout、Appender、配置文件。具体的细节实现不需要掌握。

### 输出函数

log4cpp支持不同的输出函数风格，所以需要通过构造函数分析不同的Appender需要传入哪些参数，配置文件也是一样，需要配置哪些参数也通过构造函数查看。

### 输出风格

不同的Layout对应不同的输出风格，不同的Appender支持不同的输出风格，同一个Category可以有多个subCategory，即可以有不同的输出。log4cpp提供了一些缺省的输出风格。

### Category

log4cpp通过Category进行输出，两个主要组成部分是Appender和Priority。Category是观察者模式。这里再提示一下，log4cpp中用了很多设计模式。

### 写文件

这里介绍两种方式：FlieAppender和RollingFileAppender。  
同样都是写文件，FlieAppender比RollingFileAppender效率高很多。  
一方面，两者同时以同步的方式写日志，不会缓存文件，每写一行日志都会调用一次write()，所以效率都不会太高。  
另一方面，RollingFileAppender是继承FlieAppender。本质上还是调用FlieAppender，还加上了判断文件大小等操作，因此效率会较低。尤其是判断文件大小，每次都调用lseek()，是影响效率的关键。我们对于获取文件大小的需求，不应使用lseek()，而是另外定义一个变量表示文件大小，每次写入进行累加，这样就不要每次都lseek()。  
这里再介绍一下RollingFileAppender回滚文件的原理。.log是当前要写入的文件，.log.1~.log.n是旧文件，用于回滚。n越大越旧，限制几个由传入参数决定。例如限制5个，更新过程：.log.5删除，.log.4改为.log.5，.log.3改为.log.4，以此类推，.log改为.log.1，然后再新建一个.log，即完成了更新。

muduo
-----

muduo是异步操作，写线程利用写队列，负责从队列中读取数据落盘。

### 更新和回滚文件

更新和回滚文件方式与log4cpp不同。新建一个回滚文件需要满足两个条件：一秒最多创建一个日志文件，日志文件大小达到参数kRollSize值。所以，可能出现日志文件大小超过kRollSize的情况，这一点要注意。

### 输出样式

muduo只支持Appender方式，利用setOutput()设置。如果想要设置成类似log4cpp中不同Appender不同输出的输出样式，利用logEvent做成不同的风格会好些。

### 写入数据

muduo效率的关键——append()函数。  
**1.批量缓存**  
当写队列中日志达到指定大小（默认4M）才会通知写线程来写日志。同时，写线程还有超时机制，即使没到4M，超过一定时间也会写日志，不会死等。  
**2.用了双缓存**  
方便写入数据。其实，双缓存的说法不准确。如果后端写入线程没有及时写入数据，此时还有日志append()，就需要再分配缓存。  
**3.用了双队列**  
一个用于append()，一个用于写入磁盘。减小了锁的粒度，是vector。关于加锁再提一点，不要在落盘时加锁，会导致写日志append()时拿不到锁，降低效率。  
最后还要注意一下，muduo是在日志析构~logger()时才写入缓存。

这里再回答之前提到的两个问题。第一个问题，有四种方式：一是文件批量写入，二是批量唤醒线程，三是写线程用wait\_timeout的方式刷盘，四是锁的粒度尽量小（双缓存、双队列）。第二个问题，通过coredump找回，注意编译时要加-g。